/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include "token.h"
#include "tema_svc.c"
#include <vector>
#include <iostream>
#include <fstream>
#include <set>
#include <string>
#include <map>
#include <bits/stdc++.h>
#include <cstdlib>

#define TOKEN_LEN 15

using namespace std;

struct credentials {

	credentials(string auth_token) : auth_token(auth_token), access_token(), refresh_token(), perms() {} 
	credentials() : auth_token(), access_token(), refresh_token(), perms() {} 

	string auth_token;
	string access_token;
	string refresh_token;
	unordered_map<string, string> perms;
};

// coada cu permisiuni
queue<unordered_map<string,string>> approvals_queue;
// set cu userii
set<string> users;
// set cu resurse
set<string> resources;
// authorization token - userid
unordered_map<string, string> auth_userid_tokens;
// access token - <userid, ttl>
unordered_map<string, pair<string, int>> access_userid_tokens;
// userid - credentiale
unordered_map<string, credentials> users_credentials;

/**
 *  Folosesc inca 2 map-uri "access_userid_tokens" si "access_userid_tokens" pentru ca am nevoie sa 
 *  aflu informatii nevand la userid-ul si consider ca e mai eficient decat sa fac o cautare iterand
 *  in map-ul mare de fiecare data.
 **/


int valability;

char **
request_authorization_1_svc(char **argp, struct svc_req *rqstp)
{

	static char * result;

	auto pos = users.find(*argp);
	printf("BEGIN %s AUTHZ\n", *argp);

	// Verific daca exista user-ul
	if (pos != users.end()) {
		result = generate_access_token(*argp);
		printf("  RequestToken = %s\n", result);
	} else { // Nu exista
		result = strdup("USER_NOT_FOUND");
		return &result;
	}

	// adaug o intrare in map-ul auth_userid
	auth_userid_tokens.insert({result, *argp});
	auto entry = users_credentials.find(*argp);
	// Daca nu a fost autorizat niciodata
	if (entry == users_credentials.end()) {
		users_credentials.insert({*argp, credentials(result)});
	} else {
		entry->second.auth_token = result;

	}

	return &result;
}

access_response *generate_access_refresh_tokens(access_request *argp) {
	char *access_token, *refresh_token;
	static access_response  result;

	// generez token-ul de access
	access_token = generate_access_token(argp->auth_token);
	result.access_token = strdup(access_token);
	printf("  AccessToken = %s\n", access_token);
	if (argp->generate_refresh_token) {
		refresh_token = generate_access_token(access_token);
		result.refresh_token = strdup(refresh_token);
		printf("  RefreshToken = %s\n", refresh_token);
	} else {
		result.refresh_token = strdup("");
	}
	// adaug token-ul de access si cel de refresh(null daca nu a fost generat)
	access_userid_tokens.insert({access_token, {argp->id, valability}});
	auto user_credentials = users_credentials.find(argp->id);
	user_credentials->second.access_token = access_token;
	user_credentials->second.refresh_token = result.refresh_token;
	result.ttl = valability;

	return &result;
}


access_response *
request_acces_token_1_svc(access_request *argp, struct svc_req *rqstp)
{
	static access_response  *result;
	char *access_token, *refresh_token;

	auto user_credentials = users_credentials.find(argp->id)->second;

	string old_refresh_token = user_credentials.refresh_token;
	int refresh_op_initialized = !old_refresh_token.compare(argp->auth_token);

	// veific daca e operatie de refresh
	if (refresh_op_initialized) {
		printf("BEGIN %s AUTHZ REFRESH\n", argp->id);
		result = generate_access_refresh_tokens(argp);
		return result;
	} 

	string old_auth_token = user_credentials.auth_token;

	// verific daca tokenul de autentificare e semnat
	if (strcmp(old_auth_token.c_str(), argp->auth_token) && !refresh_op_initialized) {
		result = generate_access_refresh_tokens(argp);
		
	} else { // nu e semnat
		result->access_token = strdup("REQUEST_DENIED");
		result->refresh_token = strdup("");
	}
	
	return result;
}

char **
validate_delegated_action_1_svc(action_request *argp, struct svc_req *rqstp)
{
	static char * result;
	string userid;

	auto pos = access_userid_tokens.find(argp->acces_token);
	// Verific daca exista un access token-ul
	if (pos != access_userid_tokens.end()) {
		userid = pos->second.first;
		auto res = resources.find(argp->resource);
		if (pos->second.second <= 0) {
			// Daca a expirat token-ul
			result = strdup("TOKEN_EXPIRED");
			strcpy(argp->acces_token, "");
		} else if (res == resources.end()) {
			// Nu am gasit resursa in lista de resurse
			result = strdup("RESOURCE_NOT_FOUND");
			pos->second.second--;
		} else {
			// permisiunile user-ului
			unordered_map<string, string> perms = users_credentials.find(userid)->second.perms;
			auto founded_resources = perms.find(argp->resource);
			if (founded_resources != perms.cend()) { // am gasit resursa in lista de permisiuni
				char *rights = (char*)(founded_resources->second).c_str();
				// Verific daca are drepturi.
				if ((strchr(rights, argp->op[0]) == NULL && strcmp(argp->op, "EXECUTE")) || (!strcmp(argp->op, "EXECUTE") && strchr(rights, 'X') == NULL)) {
					result = strdup("OPERATION_NOT_PERMITTED");
				} else {
					result = strdup("PERMISSION_GRANTED");
				}
			} else {
				result = strdup("OPERATION_NOT_PERMITTED");
			}
			// scad valabilitatea token-ului
			pos->second.second--;
		}

		// Fac afisarile
		if (!strcmp(result,"PERMISSION_GRANTED")) {
			printf("PERMIT (%s,%s,%s,%d)\n", argp->op,argp->resource, argp->acces_token, pos->second.second);
		} else {
			printf("DENY (%s,%s,%s,%d)\n", argp->op,argp->resource, argp->acces_token, pos->second.second);
		}
		
	} else {
		result = strdup("PERMISSION_DENIED");
		printf("DENY (%s,%s,%s,%d)\n", argp->op,argp->resource, argp->acces_token, 0);
	}
	return &result;
}

char **
approve_request_token_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	string res_line;
	string res, perms;
	int nr_resources = 0;
	unordered_map<string, string> curr_res_map;

	// luam permisiunile curente in ordine FIFO
	curr_res_map = approvals_queue.front();
	approvals_queue.pop();

	// Daca nu are permisiuni (e linie de tipul "*,-"")
	if (curr_res_map.empty()) {
		result = strdup(*argp);
	} else {
		string userid = auth_userid_tokens.find(*argp)->second;
		// Setam permisunile user-ului curent 
		users_credentials.find(userid)->second.perms = curr_res_map;
		
		// adaug "$" la final pentru a-l considera semnat
		result = strdup(strcat(*argp, "$"));
	}
	return &result;
}

void parse_input(char *users_file, char *resources_file, char *approvals_file)
{
	int rc, nr_clienti, nr_resources;
	string id, resource_name;
	string res_line;
	string res, perms;

	ifstream fd_users(users_file);
	if (fd_users.is_open()) {
		getline(fd_users, id);
		nr_clienti = atoi(id.c_str());
		for (int i = 0; i < nr_clienti; i++) {
			getline(fd_users, id);
			users.insert(id);
		}
	}

	ifstream fd_resources(resources_file);
	if (fd_resources.is_open()) {
		getline(fd_resources, resource_name);
		nr_resources = atoi(resource_name.c_str());
		for (int i = 0; i < nr_resources; i++) {
			getline(fd_resources, resource_name);
			resources.insert(resource_name);
		}
	}

	ifstream approvals(approvals_file);
	if (approvals.is_open()) {
		while(getline(approvals, res_line)) {
			stringstream check(res_line);
			unordered_map<string, string> curr_res_map;
			// impart linia in fiecare resursa si permisiuni
			while(getline(check, res, ',') && getline(check, perms, ',')) {
				// utilizatorul nu aproba cererea => map gol
				if (!res.compare("*")) {
					break;
				} else {
					curr_res_map.insert({res, perms});
				}
			}
			approvals_queue.push(curr_res_map);
		}
	}
}



int
main (int argc, char **argv)
{
	register SVCXPRT *transp;

	setbuf(stdout, NULL);

	valability = atoi(argv[4]);

	parse_input(argv[1], argv[2], argv[3]);

	pmap_unset (TEMAPROG, TEMAVERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, TEMAPROG, TEMAVERS, temaprog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (TEMAPROG, TEMAVERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, TEMAPROG, TEMAVERS, temaprog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (TEMAPROG, TEMAVERS, tcp).");
		exit(1);
	}

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}