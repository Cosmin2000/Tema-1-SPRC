/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include "token.h"
#include "tema_svc.c"
#include <vector>
#include <iostream>
#include <fstream>
#include <set>
#include <string>
#include <map>
#include <bits/stdc++.h>
#include <cstdlib>

#define TOKEN_LEN 15

using namespace std;

set<string> users;
set<string> resources;
// auth token - userid
map<string, string> auth_userid_tokens;
//userid - auth token
map<string, string> userid_auth_tokens;
// userid - map(set de permisiuni <resursa, permisiuni>)
map<string, map<string, string>> perms_map;
// access token - <userid, ttl>
map<string, pair<string, int>> access_userid_tokens;
// userid - <access token, refresh_token>
map<string, pair<string, string>>  userid_access_tokens;
ifstream approvals;
int valability;

char **
request_authorization_1_svc(char **argp, struct svc_req *rqstp)
{

	static char * result;

	auto pos = users.find(*argp);
	printf("BEGIN %s AUTHZ\n", *argp);

	if (pos != users.end()) {
		result = generate_access_token(*argp);
		printf("  RequestToken = %s\n", result);
	} else {
		result = strdup("USER_NOT_FOUND");
	}

	auth_userid_tokens.insert({result, *argp});
	auto entry = userid_auth_tokens.find(*argp);
	// Daca user-ul nu a fost autorizat niciodata
	if (entry == userid_auth_tokens.end()) {
		userid_auth_tokens.insert({*argp, result});
	} else {
		entry->second = result;

	}
	return &result;
}

access_response *generate_access_refresh_tokens(access_request *argp) {
	char *access_token, *refresh_token;
	static access_response  result;

	access_token = generate_access_token(argp->auth_token);
	result.access_token = strdup(access_token);
	printf("  AccessToken = %s\n", access_token);
	if (argp->generate_refresh_token) {
		refresh_token = generate_access_token(access_token);
		result.refresh_token = strdup(refresh_token);
		printf("  RefreshToken = %s\n", refresh_token);
	} else {
		result.refresh_token = strdup("");
	}
	access_userid_tokens.insert({access_token, {argp->id, valability}});
	auto found_userid_tokens = userid_access_tokens.find(argp->id);
	// in caz ca deja exista o intrare
	if (found_userid_tokens != userid_access_tokens.end()) {
		found_userid_tokens->second = {access_token, result.refresh_token};
	} else {
		userid_access_tokens.insert({argp->id, {access_token, result.refresh_token}});
	}
	result.ttl = valability;

	return &result;
}


access_response *
request_acces_token_1_svc(access_request *argp, struct svc_req *rqstp)
{
	static access_response  *result;
	char *access_token, *refresh_token;

	string old_refresh_token = userid_access_tokens.find(argp->id)->second.second;
	int refresh_op_initialized = !old_refresh_token.compare(argp->auth_token);

	if (refresh_op_initialized) {
		printf("BEGIN %s AUTHZ REFRESH\n", argp->id);
		result = generate_access_refresh_tokens(argp);
		return result;
	} 

	string old_auth_token = userid_auth_tokens.find(argp->id)->second;
	// printf("Am primit pentru ACCESS : OLD: %s  ACC: %s\n", old_auth_token.c_str(), argp->auth_token);

	if (strcmp(old_auth_token.c_str(), argp->auth_token) && !refresh_op_initialized) {
		result = generate_access_refresh_tokens(argp);
		
	} else {
		result->access_token = strdup("REQUEST_DENIED");
		result->refresh_token = strdup("");
	}
	
	return result;
}

char **
validate_delegated_action_1_svc(action *argp, struct svc_req *rqstp)
{
	static char * result;
	string userid;

	auto pos = access_userid_tokens.find(argp->acces_token);
	// Daca exista perechea userid-access token
	if (pos != access_userid_tokens.end()) {
		userid = get<0>(pos->second);
		auto res = resources.find(argp->resource);
		if (pos->second.second <= 0) {
			result = strdup("TOKEN_EXPIRED");
			strcpy(argp->acces_token, "");
		} else if (res == resources.end()) {
			result = strdup("RESOURCE_NOT_FOUND");
			pos->second.second--;
		} else {
			map<string, string> perms = perms_map.find(userid)->second;
			auto founded_resources = perms.find(argp->resource);
			if (founded_resources != perms.cend()) { // am gasit resursa
				char *rights = (char*)(founded_resources->second).c_str();
				if ((strchr(rights, argp->op[0]) == NULL && strcmp(argp->op, "EXECUTE")) || (!strcmp(argp->op, "EXECUTE") && strchr(rights, 'X') == NULL)) {
					result = strdup("OPERATION_NOT_PERMITTED");
				} else {
					result = strdup("PERMISSION_GRANTED");
				}
			} else {
				result = strdup("OPERATION_NOT_PERMITTED");
			}
			pos->second.second--;
		}
		if (!strcmp(result,"PERMISSION_GRANTED")) {
			printf("PERMIT (%s,%s,%s,%d)\n", argp->op,argp->resource, argp->acces_token, pos->second.second);
		} else {
			printf("DENY (%s,%s,%s,%d)\n", argp->op,argp->resource, argp->acces_token, pos->second.second);
		}
		
	} else {
		result = strdup("PERMISSION_DENIED");
		printf("DENY (%s,%s,%s,%d)\n", argp->op,argp->resource, argp->acces_token, 0);
	}
	return &result;
}

char **
approve_request_token_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	string res_line;
	string res, perms;
	int nr_resources = 0;
	map<string, string> curr_res_map;

	// scriem sau suprascriem(daca avem cerere noua) permisiunile;
	if (approvals.is_open()) {
		// citesc intrarea de approvals
		if(getline(approvals, res_line)) {
			stringstream check(res_line);
			// impart linia in fiecare resursa si permisiuni
			while(getline(check, res, ',') && getline(check, perms, ',')) {
				// utilizatorul nu aproba cererea
				if (!res.compare("*")) {
					break;
				}
				curr_res_map.insert({res, perms});
				nr_resources++;
			}
		}
	}
	

	if (nr_resources == 0) {
		result = strdup(*argp);
	} else {
		string userid = auth_userid_tokens.find(*argp)->second;
		auto perms_entry = perms_map.find(userid);
		// cautam sa vedem daca exista deja permisiuni si daca exista le suprascriem
		if (perms_entry == perms_map.end()) {
			perms_map.insert({userid, curr_res_map});
		} else {
			perms_entry->second = curr_res_map;
		}
		
		// adaug "+" la final pentru a-l considera semnat
		result = strdup(strcat(*argp, "+"));
	}
	return &result;
}




int
main (int argc, char **argv)
{
	register SVCXPRT *transp;

	// FILE *fd_clienti, *fd_resurse, *fd_aprobari;
	int rc, nr_clienti, nr_resources;
	string id, resource_name;
	setbuf(stdout, NULL);

	valability = atoi(argv[4]);

	ifstream fd_users(argv[1]);
	if (fd_users.is_open()) {
		getline(fd_users, id);
		nr_clienti = atoi(id.c_str());
		for (int i = 0; i < nr_clienti; i++) {
			getline(fd_users, id);
			users.insert(id);
		}
	}

	ifstream fd_resources(argv[2]);
	if (fd_resources.is_open()) {
		getline(fd_resources, resource_name);
		nr_resources = atoi(resource_name.c_str());
		for (int i = 0; i < nr_resources; i++) {
			getline(fd_resources, resource_name);
			resources.insert(resource_name);
		}
	}

	approvals.open(argv[3]);
	
	pmap_unset (TEMAPROG, TEMAVERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, TEMAPROG, TEMAVERS, temaprog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (TEMAPROG, TEMAVERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, TEMAPROG, TEMAVERS, temaprog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (TEMAPROG, TEMAVERS, tcp).");
		exit(1);
	}

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}