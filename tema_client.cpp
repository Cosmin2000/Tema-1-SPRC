/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "tema.h"
#include <vector>
#include <iostream>
#include <fstream>
#include <string>
#include <map>

using namespace std;

// userid - < <access token, refresh_token> , ttl >
map<string, pair<pair<string,string>, int>> userid_access_tokens;


void make_request_access(access_request  *request_access, CLIENT *clnt, char *user, char **auth_token) {
	access_response  *request_access_response;


	// Am primit tokenul de autorizare de la utilizator (semnat sau nu)
	request_access_response = request_acces_token_1(request_access, clnt);
	if (request_access_response == (access_response *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	// NU am primit REQUEST_DENIED
	if(strcmp(request_access_response->access_token, "REQUEST_DENIED")) {
		auto userid_access_entry = userid_access_tokens.find(user);
		// Verific daca exista deja un access token pentru acest user
		if (userid_access_entry == userid_access_tokens.end()) {
			userid_access_tokens.insert({user, {{request_access_response->access_token, request_access_response->refresh_token}, request_access_response->ttl}});
		} else {
			userid_access_entry->second.first = {request_access_response->access_token, request_access_response->refresh_token};
			userid_access_entry->second.second = request_access_response->ttl;

		}

		// Daca nu e refresh initiat
		if (auth_token != NULL) {
			printf("%s -> %s", *auth_token,request_access_response->access_token);
			if (request_access->generate_refresh_token) {
				printf(",%s", request_access_response->refresh_token);
			}
			printf("\n");
		}
		
	} else {
		printf("REQUEST_DENIED\n");
	}
}

void make_request(char *user, CLIENT *clnt, int generate_refresh_token) {
	char * *auth_token;
	char * *signed_token;
	access_response  *request_access_response;
	access_request  request_access;


	auth_token = request_authorization_1(&user, clnt);
	if (auth_token == (char **) NULL) {
		clnt_perror (clnt, "call failed");
	}
	// printf("Request Token: %s\n ", *auth_token);
	
	if (strcmp(*auth_token, "USER_NOT_FOUND")) {
		// Facem cererea de aprobare 
		signed_token = approve_request_token_1(auth_token, clnt);
		if (signed_token == (char **) NULL) {
			clnt_perror (clnt, "call failed");
		}
		request_access.id = strdup(user);
		request_access.auth_token = strdup(*signed_token);
		request_access.generate_refresh_token = generate_refresh_token;
		make_request_access(&request_access, clnt, user, auth_token);
	} else {
		printf("USER_NOT_FOUND\n");
	}
}

void
temaprog_1(char *host, char *fd_op)
{
	CLIENT *clnt;
	char * *auth_token;
	char * request_authorization_1_arg;
	access_response  *request_access_response;
	access_request  request_access;
	char * *resource_server_response;
	action  resource_request_params;
	char * *signed_token;
	char * approve_request_token_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, TEMAPROG, TEMAVERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	string line, op;
	char *user;
	char *ptr;
	char *value;
	ifstream fd_operatii(fd_op);
	if (fd_operatii.is_open()) {
		while(getline(fd_operatii, line)) {
			ptr = strtok((char *)line.c_str(), ",");
			user = ptr;
			op = strtok(NULL, ",");
			value = strtok(NULL,",");

			// cout << user << " " << op << " " << value << endl;
		
			if (!op.compare("REQUEST")) { // Avem REQUEST
				make_request(user, clnt, atoi(value));
			} else { // Avem cerere de resursa
				auto found = userid_access_tokens.find(user);
				if (found != userid_access_tokens.end()) {
					// daca expira si are refresh token
					if (found->second.second == 0 && found->second.first.second.compare("")) {
						request_access.id = strdup(user);
						request_access.auth_token = strdup(found->second.first.second.c_str());
						request_access.generate_refresh_token = 1;
						// printf("FACE REFRESH %s %s %d\n", request_access.id,request_access.auth_token, request_access.generate_refresh_token);
						make_request_access(&request_access, clnt, user, NULL);
					}
					resource_request_params.acces_token = (char*)userid_access_tokens.find(user)->second.first.first.c_str();
				} else {
					resource_request_params.acces_token = strdup("");
				}
				
				resource_request_params.op = (char *)op.c_str();
				resource_request_params.resource = (char *)value;

				resource_server_response = validate_delegated_action_1(&resource_request_params, clnt);
				if (resource_server_response == (char **) NULL) {
					clnt_perror (clnt, "call failed");
				}
				printf("%s\n", *resource_server_response);
				if (strcmp(*resource_server_response, "PERMISSION_DENIED") && userid_access_tokens.find(user) != userid_access_tokens.end()) {
					userid_access_tokens.find(user)->second.second--;
				}
			}
		}
	}



#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];

	temaprog_1 (host, argv[2]);
exit (0);
}
